# Grokking Algorithms

By Aditya Bhargava

> Click for [Website](https://www.manning.com/books/grokking-algorithms) and [Github Repository](https://github.com/egonschiele/grokking_algorithms)

## Roadmap

The first three chapters of this book lay the foundations:

### Chapter 1

You’ll learn your first practical algorithm: binary search. You also learn to analyze the speed of an algorithm using Big O notation. Big O notation is used throughout the book to analyze how slow or fast an algorithm is.xvi about this book.

### Chapter 2

You’ll learn about two fundamental data structures: arrays and linked lists. These data structures are used throughout the book, and they’re used to make more advanced data structures like hash tables (chapter 5).

### Chapter 3

You’ll learn about recursion, a handy technique used by many algorithms (such as quicksort, covered in chapter 4). In my experience, Big O notation and recursion are challenging topics for beginners. So I’ve slowed down and spent extra time on these sections.

The rest of the book presents algorithms with broad applications:

### Problem-solving techniques

Covered in chapters 4, 8, and 9. If you come across a problem and aren’t sure how to solve it efficiently, try
divide and conquer (chapter 4) or dynamic programming (chapter 9). Or you may realize there’s no efficient solution, and get an approximate answer using a greedy algorithm instead (chapter 8).

### Hash tables

Covered in chapter 5. A hash table is a very useful data structure. It contains sets of key and value pairs, like a person’s name and their email address, or a username and the associated password. It’s hard to overstate hash tables’ usefulness. When I want to solve a problem, the two plans of attack I start with are “Can I use a hash table?” and “Can I model this as a graph?”

### Graph algorithms

Covered in chapters 6 and 7. Graphs are a way to model a network: a social network, or a network of roads, or neurons, or any other set of connections. Breadth-first search (chapter 6) and Dijkstra’s algorithm (chapter 7) are ways to find the shortest distance between two points in a network: you can use this approach to calculate the degrees of separation between two people or the shortest route to a destination.

### K-nearest neighbors (KNN)

Covered in chapter 10. This is a simple machine-learning algorithm. You can use KNN to build a
recommendations system, an OCR engine, a system to predict stock values—anything that involves predicting a value (“We think Adit will rate this movie 4 stars”) or classifying an object (“That letter is a Q”).

### Next steps

Chapter 11 goes over 10 algorithms that would make good further reading
